#!/bin/bash
LOGFILE=~/logs.txt
TODAY=$(date '+%Y-%m-%d')
TIME=$(date '+%H:%M:%S')
ENTRY="  [$TIME] $*"

touch "$LOGFILE"

# Read all lines of the file
lines=()
while IFS= read -r line; do
  lines+=("$line")
done < "$LOGFILE"

# Identify all date header lines
declare -a date_indexes=()
for i in "${!lines[@]}"; do
  [[ "${lines[$i]}" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] && date_indexes+=($i)
done

# Find today's section index, if it exists
today_line=-1
for idx in "${date_indexes[@]}"; do
  if [[ "${lines[$idx]}" == "$TODAY" ]]; then
    today_line=$idx
    break
  fi
done

if [[ $today_line -eq -1 ]]; then
  # No today's section; prepend new group at the top
  {
    echo "$TODAY"
    echo "$ENTRY"
    echo
    printf '%s\n' "${lines[@]}"
  } > "$LOGFILE.tmp"
else
  # Find end of today's section (either next date header or end of file)
  section_end=${#lines[@]}
  for ((i=today_line+1; i<${#lines[@]}; i++)); do
    [[ "${lines[$i]}" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] && { section_end=$i; break; }
  done
  # Prepare output
  {
    # All groups before today's
    for ((gi=0; gi<today_line; )); do
      # Find next header after gi
      next=${#lines[@]}
      for ((i=gi+1; i<${#lines[@]}; i++)); do
        [[ "${lines[$i]}" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] && { next=$i; break; }
      done
      for ((i=gi; i<next; i++)); do
        echo "${lines[$i]}"
      done
      echo
      gi=$next
    done
    # Today's group: header
    echo "$TODAY"
    # Entries (skip blanks), plus new, sorted
    {
      for ((i=today_line+1; i<section_end; i++)); do
        [[ -n "${lines[$i]// /}" ]] && echo "${lines[$i]}"
      done
      echo "$ENTRY"
    } | sort
    echo
    # Remaining groups (after today's)
    gi=$section_end
    while ((gi<${#lines[@]})); do
      # Find next header after gi
      next=${#lines[@]}
      for ((i=gi+1; i<${#lines[@]}; i++)); do
        [[ "${lines[$i]}" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] && { next=$i; break; }
      done
      for ((i=gi; i<next; i++)); do
        echo "${lines[$i]}"
      done
      # Only print a blank line if not at end
      ((next<${#lines[@]})) && echo
      gi=$next
    done
  } > "$LOGFILE.tmp"
fi

mv "$LOGFILE.tmp" "$LOGFILE"
